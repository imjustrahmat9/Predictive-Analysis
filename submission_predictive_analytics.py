# -*- coding: utf-8 -*-
"""Submission_Predictive_Analytics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YeibWJvAaLXJKJT66gxeFYyEk1IXrm8h

# A. Import Library

Pada tahap ini, kita akan mengimport seluruh library python yang diperlukan dalam pengembangan projek
"""

# Upload file dengan google colab
from google.colab import userdata
import os
import random
import textwrap
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from xgboost import XGBClassifier
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier, plot_tree
from sklearn.naive_bayes import GaussianNB
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import GridSearchCV, RandomizedSearchCV, train_test_split, cross_val_score
from sklearn.preprocessing import LabelEncoder, OrdinalEncoder, OneHotEncoder, StandardScaler
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

from google.colab import drive
drive.mount('/content/drive')

"""# B. Data Loading

Pada tahap, kita akan mengambil dataset dari luar (Kaggle) yakni Dataset Students-Performance yang diupload oleh Rabie El Kharoua
"""

import kagglehub

# Download latest version
path = kagglehub.dataset_download("rabieelkharoua/students-performance-dataset")

print("Path to dataset files:", path)

"""Selanjutnya, kita akan mengekstrak file zip dan mengambil dataset dalam format csv dan disimpan pada variabel dataframe df_student"""

! unzip "/content/sample_data/archive(1).zip"

df_students = pd.read_csv('/content/Student_performance_data _.csv')

"""Selanjutnya, kita melihat isi dari dataset secara sekilas dengan `.head()` dan ukuran dari dataset dengan `.shape`"""

print(df_students.shape)
df_students.head(100)

"""Dari tabel hasil diatas terdapat 2392 baris dan 15 kolom pada dataset

# C. Exploratory Data Analysis

## Deskripsi Variabel

Berikut adalah arti dari variabel yang digunakan dalam dataset:
#### StudentID
StudentID: Pengenal unik yang diberikan kepada setiap siswa (1001 hingga 3392).
#### Detail Demografis
1. Age: Usia siswa berkisar antara 15 hingga 18 tahun.
2. Gender: Jenis kelamin siswa, di mana 0 mewakili Pria dan 1 mewakili Wanita.
3. Ethnicity: Etnisitas siswa, dikodekan sebagai berikut:
0: Kaukasia
1: Afrika-Amerika
2: Asia
3: Lainnya
4. ParentalEducation: Tingkat pendidikan orang tua, dikodekan sebagai berikut:
0: Tidak ada
1: Sekolah Menengah Atas
2: Beberapa Perguruan Tinggi
3: Sarjana
4: Lebih tinggi

#### Kebiasaan Belajar
1. StudyTimeWeekly: Waktu belajar mingguan dalam jam, mulai dari 0 hingga 20.
2. Absences: Jumlah ketidakhadiran selama tahun ajaran, mulai dari 0 hingga 30.
3. Tutoring: Status bimbingan belajar, di mana 0 menunjukkan Tidak dan 1 menunjukkan Ya.

#### Keterlibatan Orang Tua
ParentalSupport: Tingkat dukungan orang tua, dengan kode sebagai berikut:
0: Tidak ada
1: Rendah
2: Sedang
3: Tinggi
4: Sangat Tinggi

#### Kegiatan Ekstrakurikuler
Extracurricular: Partisipasi dalam kegiatan ekstrakurikuler, di mana 0 menunjukkan Tidak dan 1 menunjukkan Ya.
Sports: Partisipasi dalam olahraga, di mana 0 menunjukkan Tidak dan 1 menunjukkan Ya.
Music: Partisipasi dalam kegiatan musik, di mana 0 menunjukkan Tidak dan 1 menunjukkan Ya.
Volunteering: Partisipasi dalam kegiatan sukarela, di mana 0 menunjukkan Tidak dan 1 menunjukkan Ya.

#### Kinerja Akademik
GPA: Indeks Prestasi Kumulatif dengan skala dari 2.0 hingga 4.0, yang dipengaruhi oleh kebiasaan belajar, keterlibatan orang tua, dan kegiatan ekstrakurikuler.

#### Variabel Target: GradeClass
GradeClass: Klasifikasi nilai siswa berdasarkan IPK:
0: 'A' (IPK >= 3,5)
2: 'C' (2.5 <= IPK < 3.0)
1: 'B' (3.0 <= IPK < 3.5)
3: 'D' (2.0 <= IPK < 2.5)
4: 'F' (IPK < 2.0)

Selanjutnya, kita akan menampilkan informasi dataset siswa
"""

df_students.info()

"""Dari hasil yang ditampilkan, terdapat 12 variabel bertipe int64 dan 3 variabel bertipe fload64

Langkah selanjutnya, kita tampilkan deskripsi dataset siswa
"""

df_students.describe()

"""Dari hasil itu, kita bisa lihat ringkasan statistiknya, mulai dari jumlah datanya, nilai rata-rata, standar deviasi, nilai paling kecil, paling besar, sampai persentil 25%, 50%, dan 75% di setiap kolom pada dataframe siswa.

###Menangani Missing Value

Pada tahap ini kita akan mengecek data yang tidak valid pada dataset
"""

#cek nilai kosong
pd.DataFrame({'Nilai yang Kosong':df_students.isna().sum()})

"""Dari hasil yang ditampilkan, data tidak memiliki nilai kosong (null) pada setiap kolom dataset

### Memeriksa Duplikasi Data
"""

#Perika data yang ganda
print(f'Jumlah data yang ganda: {df_students.duplicated().sum()}')

"""Hasil yang ditampilkan adalah 0, dengan demikian data tidak ada yang ganda (dupikat)

### Konversi nilai numerik kategorikal ke objek(string)

Langkah selanjutnya, karena dataset kita tipe kategorikal sudah dalam bentuk nilai numerik, maka kita perlu membuat fungsi konversi nilai number kategorikal ke objek (string). Tujuan dari langkah ini yaitu untuk menampilkan label fitur visualisasi dalam proses analisis data dengan teknik *Univariate EDA* dan *Multivariate EDA*.
"""

# Menonaktifkan peringatan terkait downcasting
pd.set_option('future.no_silent_downcasting', True)

# Mengganti nilai number kategori ke String Keterangan
def konversi_numerik_to_objek ():
  df_students['Gender'] = df_students['Gender'].replace({1: 'Wanita', 0: 'Pria'})
  df_students['Extracurricular'] = df_students['Extracurricular'].replace({1:'Yes', 0:'No'})
  df_students['Tutoring'] = df_students['Tutoring'].replace({1: 'Yes', 0: 'No'})
  df_students['Music'] = df_students['Music'].replace({1: 'Yes', 0: 'No'})
  df_students['Sports'] = df_students['Sports'].replace({1: 'Yes', 0: 'No'})
  df_students['Volunteering'] = df_students['Volunteering'].replace({1: 'Yes', 0: 'No'})
  df_students['ParentalSupport'] = df_students['ParentalSupport'].replace({4: 'Very High', 3: 'High', 2: 'Moderate', 1: 'Low', 0: 'None'})
  df_students['GradeClass'] = df_students['GradeClass'].replace({4.0: 'Grade F', 3.0: 'Grade D', 2.0: 'Grade C', 1.0: 'Grade B', 0.0: 'Grade A'})

"""Berikutnya kita akan memanggil fungsi konversi numerik ke objek(string) dan menampilkan dataset dengan fungsi `head()`"""

#Memanggil fungsi konversi numerik ke objek(string)
konversi_numerik_to_objek()

#menampilkan datasetd dengan fungsi head()
df_students.head()

"""## Univariate Analysis EDA

#### 1. Membagi variabel-variabel yang ada menjadi 2 kategori, yaitu kategori numerikal dan kategori kategorical
"""

# Menuliskan seluruh nama kolom numerikal
kolom_data_numerikal = ["Age", "StudyTimeWeekly", "Absences", "GPA"]
# Menuliskan seluruh nama kolom numerikal
kolom_data_kategorical = ["Gender", "Ethnicity", "ParentalEducation", "Tutoring", "ParentalSupport", "Extracurricular", "Sports", "Music", "Volunteering", "GradeClass"]

"""#### 2. Melihat nilai-nilai pada kolom kategorikal"""

# Menghitung jumlah nilai yang unik/berbeda dari masing-masing variabel pada kolom kategorikal
jumlah_unik = df_students[kolom_data_kategorical].nunique()

# Menampilkan nilai yang unik/berbeda dari masing-masing variabel pada kolom kategorikal
nilai_unik = df_students[kolom_data_kategorical].apply(lambda x: sorted(x.unique()))

# Menampilkan hasil dalam bentuk DataFrame
pd.DataFrame({"Total Nilai Berbeda": jumlah_unik, "Nilai-Nilai": nilai_unik})

"""Dapat dilihat pada tabel nilai berbeda pada:
1. Kolom gender = 2;
2. Kolom Etnicity = 4;
3. Kolom ParentalEducation = 5;
4. Kolom Tutoring = 2;
5. Kolom ParentalSupport = 5;
6. Kolom Extracurricular = 2;
7. Kolom Sports = 2;
8. Kolom Music = 2;
9. Kolom Volunteering = 2;
10. Kolom GradeClass(Variabel Target) = 5;

#### 3. Menampilkan pesebaran data kolom kategorikal dalam bentuk grafik boxplot

Pada tahap ini, kita akan membuat visualisasi data kategorikal dalam bentuk grafik dengan menggunakan library python `matplotlib`
"""

# Membentuk plot dengan subplot sejumlah 9 berukuran 3 x 3
fig, axes = plt.subplots(2, 5, figsize = (18, 18))

# Mengubah array multi dimensi menjadi array 1 dimensi
axes = axes.flatten()

# Fungsi untuk menghasilkan palet warna acak
def random_palette(n_colors):
    return ["#%06x" % random.randint(0, 0xFFFFFF) for _ in range(n_colors)]

# Memberikan keterangan kolom-kolom kategorikal yang akan digunakan
keterangan_kolom_kategorikal = [ "Jenis Kelamin",
                                "Etnis",
                                "Pendidikan Orang Tua",
                                "Bimbingan Belajar",
                                "Dukungan Orang Tua",
                                "Kegiatan Ekstrakulikuler",
                                "Olahraga",
                                "Musik",
                                "Kegiatan Sosial",
                                "Prestasi Siswa"]

# Panggil fungsi numerik to objek
konversi_numerik_to_objek()

# Membentuk chart jumlah dalam bentuk bar char untuk masing-masing kolom
for i, kolom in enumerate(df_students[kolom_data_kategorical].columns):
    unique_values = df_students[kolom].nunique()  # Hitung jumlah kategori unik
    palette = random_palette(unique_values)  # Palet warna acak
    sns.countplot(x=kolom, data=df_students, ax = axes[i], hue = kolom, palette=palette)
    #sns.countplot(x = kolom, data = df_students, ax = axes[i], hue = kolom)

    # Menambahkan judul untuk masing-masing chart
    judul = "\n".join(textwrap.wrap(f"Grafik dari Jumlah {keterangan_kolom_kategorikal[i]}", width = 50))
    axes[i].set_title(judul)
    axes[i].title.set_size(12)

    # Mengatur label x
    axes[i].tick_params(axis = "x", labelrotation = 90)
    axes[i].tick_params(axis = "both", which = "major", labelsize = 12)
    axes[i].set_xlabel("")

# Mengatur susunan agar tidak berhimpitan
plt.tight_layout()


# Menampilkan plot
plt.show()

"""Berdasarkan grafik data kategorikal yang ditampilkan, dapat dilihat bahwa:
1. Grafik jenis kelamin, menunjukan jumlah merata antara laki-laki dan perempuan.
2. Grafik Etnis, menunjukan mayoritas siswa berasal dari etnis kaukasia.
3. Grafisk pendidikan orangtua, menunjukan mayoritas pendidikan orang tua yakni pensisikan tinggi dan sarjana
4. Grafik bimbingan belajar, menunjukan mayoritas siswa tidak mengikuti bimbingan belajar.
5. Grafik dukungan orang tua, menunjukan mayoritas dukungan orang tua berada di level sdang dan tinggi.
6. Grafik Ekstrakulikuler(EKtrakulikuler, Olahraga, Musik dan Sukrelawan), menujukan rendahnya minat siswa pada kegiatan diluar sekolah.

#### 4. Menampilkan pesebaran data kolom numerikal dalam bentuk grafik boxplot

Pada tahap ini, kita akan membuat visualisasi data numerikal dalam bentuk grafik dengan menggunakan library python `matplotlib`
"""

# Menuliskan seluruh nama kolom numerikal
columns_name = ["Age", "StudyTimeWeekly", "Absences", "GPA"]

# Membentuk plot berukuran 24 x 12
plt.figure(figsize = (24, 12))

# Membentuk plot berisi 8 subplot, dengan setiap subplot merupakan boxplot
for i in range(len(columns_name)):

    # Membentuk plot dengan subplot berukuran 4 x 2
    plt.subplot(4, 2, i + 1)
    sns.boxplot(x = df_students[columns_name[i]])
    plt.title('Boxplot dari {}'.format(columns_name[i]))
    plt.tight_layout()

"""Pada grafik yang ditampilkan menunjukan visualisasi data Lama Belajar setiap minggu dengan Prestasi Siswa yang diperoleh.
1. Pada kolom Age, dapat dilihat rata-rata siswa berumur 15-17 tahun. Dapat disimpulkan tidak ada Outlier yang tersebar.
2. Pada kolom StudyTimeWeekly, dapat dilihat bahwa rata-rata siswa memiliki waktu belajar 5-14 jam per minggu.
3. Pada kolom absences, dapat dilihat bahwa rata-rata siswa memiliki jumlah ketidakhadiran 6 - 23 hari. Dapat disimpulkan 1. Pada kolom Age, dapat dilihat rata-rata siswa berumur 15-17 tahun. Dapat disimpulkan tidak ada Outlier yang tersebar.
4. Pada kolom GPA, dapat dilihat bahwa rata-rata prestasi siswa diantara 1,2 - 2,7 dan tidak memiliki outlier.

#### 5. Melihat jumlah kategori kelas terbaik pada kolom GradeClass

Pada tahap ini, ditampilkan lebih detail mengenai jumlah dari masing-masing tingkat kelas terbaik yang menjadi target kita untuk mengetahui jumlah secara umum.
"""

prestasi_siswa = df_students.GradeClass.value_counts()
prestasi_siswa

"""Dari tabel kelas terbaik (GradeClass) yang ditampilkan menununjukan mayoritas prestasi siswa berada di kategori Grade F(Prestasi terendah) yakni 1211 siswa sedangkan minioritas siswa berada pada kategori Grade A (Kelas tertinggi) yakni 107

#### 5. Membuat pie chart kolom GradeClass

Pada tahap ini, kita akan melihat persebaran data dari masing-masing kategori kelas pada kolom GradeClass.
"""

# Membuat variabel label dan value
label = prestasi_siswa.index.tolist()
value = prestasi_siswa.values.tolist()

# Membentuk pie chart untuk melihat persebaran data dari masing-masing tingkat berat badan
plt.figure(figsize = (7, 7))
plt.pie(value, labels = label, autopct = "%1.1f%%", startangle = 180, radius = 0.75)

# Menambahkan legend pada pie chart
plt.legend(loc = "upper center", bbox_to_anchor = (1, 1))

# Menambahkan judul pada plot
plt.title("Distribusi Prestasi Siswa")

# Menampilkan plot
plt.show()

"""Dari grafik diatas menunjukan ditas 50.6% siswa berada pada Grade F (kelas terendah), 4.5% siswa berada pada Grade A (kelas tertinggi). Sedangkan siswa yang lainnya berada pada Grade B (11.2%), Grade C(16.3%) dan Grade D (17.3%)

### 6. Membentuk histogram dari variabel-variabel numerikal

Pada tahap ini, akan diperlihatakan pesebaran data pada histogram semua variabel numerikal
"""

# Membentuk plot dengan subplot sejumlah 4 berukuran 8 x 8
fig, axes = plt.subplots(2, 2, figsize = (8, 8))

# Mengubah array multi dimensi menjadi array 1 dimensi
axes = axes.flatten()

# Menambahkan satuan dari masing-masing kolom
labels = ["Tahun", "Jam", "Hari", "Poin"]

# Fungsi untuk menghasilkan warna acak
def random_color():
    return "#%06x" % random.randint(0, 0xFFFFFF)

# Mendeskripsikan kolom-kolom numerikal yang akan digunakan
keterangan_kolom_numerikal = ["Usia",
                             "Waktu Belajar setiap Minggu",
                             "Absen",
                             "Prestasi Siswa"]

# Membentuk plot jumlah dalam bentuk histogram plot untuk masing-masing kolom
for i, kolom in enumerate(df_students[kolom_data_numerikal].columns):
    sns.histplot(data = df_students, x = kolom, kde = True, ax = axes[i])

    # Menambahkan judul untuk masing-masing plot
    judul = "\n".join(textwrap.wrap(f"Plot Histogram dari {keterangan_kolom_numerikal[i]}", width = 30))
    axes[i].set_title(judul)
    axes[i].title.set_size(12)

    # Mengatur label x
    axes[i].set_xlabel(labels[i])
    axes[i].set_ylabel("Total")

# Mengatur susunan agar tidak berhimpitan
plt.tight_layout()

# Menampilkan plot
plt.show()

"""Berdasarkan gambar diatas, dapat dilihat bahwa plot histrogram usia, waktu belajar setiap minggu, absen dan nilai siswa cukup berdistribusi normal.

## Multivariate Analysis EDA

Pada bagian ini, akan ditunjukan hubungan antara dua variabel biasa disebut sebagai bivariate EDA. Selanjutnya, kita akan melakukan analisis data pada fitur kategori dan numerik

### 1. Ananlisis data pada fitur numerik _StudyTimeWeekly_ (Waktu belajar setiap minggu) dengan _GPA_ (Nilai Prestasi)
"""

# Menghitung garis regresi
x = df_students['StudyTimeWeekly']
y = df_students['GPA']
m, b = np.polyfit(x, y, 1)  # Mencari slope dan intercept

# Scatter plot
plt.figure(figsize=(8, 6))
plt.scatter(x, y, alpha=0.7, color='#78B3CE', label='Data')

# Garis regresi
plt.plot(x, m*x + b, color='red', linestyle='--', label='Garis Regresi')

# Menambahkan label, judul, dan legenda
plt.title("Pengaruh Waktu Belajar Setiap Minggu terhadap Prestasi Siswa", fontsize=14)
plt.xlabel("Ketidakhadiran (Absen)", fontsize=12)
plt.ylabel("Prestasi Siswa (GPA)", fontsize=12)
plt.legend()
plt.grid(alpha=0.5, linestyle='--')
plt.show()

"""Dari gambar di atas, kelihatan kalau garis regresinya naik dari bawah ke atas, yang artinya makin banyak waktu belajar siswa, makin tinggi juga prestasi atau GPA-nya

### 2. Ananlisis data pada fitur numerik _Absences_ (Ketidakhadiran) dengan _GPA_ (Nilai Prestasi)
"""

import numpy as np

# Menghitung garis regresi
x = df_students['Absences']
y = df_students['GPA']
m, b = np.polyfit(x, y, 1)  # Mencari slope dan intercept

# Scatter plot
plt.figure(figsize=(8, 6))
plt.scatter(x, y, alpha=0.7, color='#78B3CE', label='Data')

# Garis regresi
plt.plot(x, m*x + b, color='red', linestyle='--', label='Garis Regresi')

# Menambahkan label, judul, dan legenda
plt.title("Pengaruh Ketidakhadiran (Absen) terhadap Prestasi Siswa", fontsize=14)
plt.xlabel("Ketidakhadiran (Absen)", fontsize=12)
plt.ylabel("Prestasi Siswa (GPA)", fontsize=12)
plt.legend()
plt.grid(alpha=0.5, linestyle='--')
plt.show()

"""Dari gambar di atas, kelihatan garis regresinya menurun dari atas ke bawah, yang nunjukkin kalau makin sering siswa absen, makin turun juga prestasinya atau GPA-nya.

### 3. Ananlisis data pada fitur kategori _Tutoring_ (Bimbingan Belajar) dengan _GradeClass_ (Kategori Kelas)
"""

# Menentukan urutan Grade Class
grade_order = ['Grade A', 'Grade B', 'Grade C', 'Grade D', 'Grade F']

# Membentuk plot predikat dalam bentuk bar plot antara prestasi siswa dan waktu belajar setiap minggu
plt.figure(figsize = (8, 6))
sns.countplot(x = "GradeClass", data = df_students, hue = "Tutoring", order=grade_order)

# Menambahkan judul pada plot
plt.title("Pebandingan Bimbingan Belajar terhadap Prestasi Siswa")

# Menambahkan label sumbu x dan y pada plot
plt.xticks(rotation = 90)
plt.xlabel("Prestasi Siswa")
plt.ylabel("Jumlah")

# Menampilkan plot
plt.show()

"""Berdasarkan gambar diatas, dapat dilihat bahwa paling banyak siswa yang tidak mengikuti bimbingan belajar yang mendapat prestasi kelas paling rendah yakni pada kategori kelas F (Grade F)

### 4. Ananlisis data pada fitur kategori _Genre_ (Jenis Kelamin) dengan  _GradeClass_ (Kategori Kelas)
"""

# Menentukan urutan Grade Class
grade_order = ['Grade A', 'Grade B', 'Grade C', 'Grade D', 'Grade F']

# Membentuk plot predikat dalam bentuk bar plot antara prestasi siswa dan waktu belajar setiap minggu
plt.figure(figsize = (8, 6))
sns.countplot(x = "GradeClass", data = df_students, hue = "Gender", order=grade_order)

# Menambahkan judul pada plot
plt.title("Pengaruh Jenis Kelamin terhadap Prestasi Siswa")

# Menambahkan label sumbu x dan y pada plot
plt.xticks(rotation = 90)
plt.xlabel("Prestasi Siswa")
plt.ylabel("Jumlah")

# Menampilkan plot
plt.show()

"""Berdasarkan Grafik diatas, dapat dilihat bahwa pria lebih dominan memiliki prestasi kelas lebih tinggi dibandingkan dengan wanita

### 5. Ananlisis data pada fitur kategori kegiatan non akademik (_Extracurricular_, _Sports_, _Music_, _Volunteering_) dengan _GPA_ (Nilai Prestasi)
"""

# Kolom yang berisi informasi kegiatan
aktivitas = ['Extracurricular', 'Sports', 'Music', 'Volunteering']

# Menghitung rata-rata GPA untuk setiap kategori kegiatan
average_gpa = {}

for kegiatan in aktivitas:
    # Grouping by kegiatan (Yes/No) dan menghitung rata-rata GPA
    avg_gpa_per_kegiatan = df_students.groupby(kegiatan, observed=False)['GPA'].mean()
    average_gpa[kegiatan] = avg_gpa_per_kegiatan

# Membuat subplots untuk menampilkan rata-rata GPA berdasarkan kegiatan
fig, axes = plt.subplots(2, 2, figsize=(8, 8))

# Flat axes untuk akses yang lebih mudah
axes = axes.flatten()

# Plot setiap kategori
for i, kegiatan in enumerate(aktivitas):
    # Membuat bar plot
    axes[i].bar(average_gpa[kegiatan].index, average_gpa[kegiatan].values, color=['#1F509A', '#EB5B00'])

    # Menambahkan judul dan label
    axes[i].set_title(f"Pengaruh {kegiatan} terhadap GPA")
    axes[i].set_xlabel(kegiatan)
    axes[i].set_ylabel("Rata-rata GPA")

    # Menambahkan keterangan Yes/No pada sumbu x
    axes[i].set_xticks([0, 1])  # Mengatur posisi xticks
    axes[i].set_xticklabels(['No', 'Yes'], fontsize=12)  # Menambahkan keterangan Yes/No

plt.tight_layout()
plt.show()

"""Berdasarkan grafik diatas, dapat dilihat bahwa mayoritas siswa yang tidak mengikuti kegiatan ekstrakulikuler, olahraga dan musik mempengaruhi turunya nilai pretasi (GPA)

### 6. Ananlisis data pada fitur kategori _ParentalSupport_ (Dukungan Orang Tua) dengan _GradeClass_ (Kategori Kelas)
"""

# Menentukan urutan Grade Class
grade_order = ['Very High', 'High', 'Moderate', 'Low', 'None']

# Membuat Box Plot untuk pengaruh dukungan orang tua terhadap GPA
plt.figure(figsize=(8, 8))
sns.barplot(x='ParentalSupport', y='GPA', data=df_students, hue='ParentalSupport', order=grade_order, legend=True)

# Menambahkan legend (jika diperlukan untuk hue atau tambahan kategori)
legend = plt.legend(title="Parental Support", loc='upper left', bbox_to_anchor=(1, 1))

# Menambahkan judul dan label
plt.title("Pengaruh Dukungan Orang Tua terhadap GPA", fontsize=14)
plt.xlabel("Dukungan Orang Tua", fontsize=12)
plt.ylabel("GPA Siswa", fontsize=12)

# Menampilkan plot
plt.show()

"""Berdasarkan grafik diatas, dapat dilihat bahwa dukungan orang tua sangat mempengaruhin nilai prestasi siswa (GPA). Semakin tinggi dukungan orang tua, maka semakin meningkat nilai prestasi dari anaknya.

### 7. Melihat korelasi variabel numerik dengan menggunakan _Heatmap_
"""

# Menghitung matriks korelasi hanya untuk kolom numerik
numerical_corr_matrix = df_students[kolom_data_numerikal].corr()

# Membuat heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(
    numerical_corr_matrix,
    annot=True,          # Menampilkan nilai korelasi di dalam heatmap
    fmt=".2f",           # Format angka dua desimal
    cmap="coolwarm",     # Warna biru untuk korelasi negatif, merah untuk positif
    linewidths=0.5,      # Garis antar sel dalam heatmap
    cbar=True            # Menampilkan color bar
)

# Menambahkan judul
plt.title("Heatmap Korelasi Variabel Numerik (Student Performance)", fontsize=14)

# Menampilkan heatmap
plt.show()

"""Berdasarkan gambar diatas, dapat diliha bahwa:
1. Korelasi negatif yang cukup kuat dengan ketidakhadiran(Absences).
2. Korelasi positif yang cukup lemah dengan waktu belajar setiap minggu(StudyTimeWeekly).

### 8. Melihat _Plot Scatter_ yang Memiliki Nilai Korelasi Positif dan Negatif
"""

# Membentuk plot dengan subplot sejumlah 4 berukuran 2 x 2
fig, axes = plt.subplots(1, 2, figsize = (12,6))

# Mengubah array multi dimensi menjadi array 1 dimensi
axes = axes.flatten()

# Menambahkan satuan dari masing-masing kolom
labels = ["Hari", "Jam"]

# Membentuk dictionary dari variabel yang memiliki nilai korelasi lebih dari / sama dengan 0.2
data_x = {0: "Absences", 1: "StudyTimeWeekly"}

# Mendeskripsikan kolom-kolom numerikal yang akan digunakan berdasarkan data map negatif
deskripsi_kolom = ["Ketidakhadiran (Absen)",
                   "Waktu Belajar Setiap Minggu"]

# Membentuk plot scatter untuk masing-masing kolom beserta garis trend
for keys, values in data_x.items():
    sns.scatterplot(data = df_students, x = values, y = "GPA", ax = axes[keys], label='Siswa')
    sns.regplot(data = df_students, x = values, y = "GPA", scatter = False, ax = axes[keys], color=  "#E4003A", label="Garis Regresi")

    # Menambahkan judul untuk masing-masing plot
    judul = "\n".join(textwrap.wrap(f"Plot Scatter dari GPA Terhadap {deskripsi_kolom[keys]}", width = 50))
    axes[keys].set_title(judul)
    axes[keys].title.set_size(12)

    # Menambahkan label sumbu x dan y pada plot
    axes[keys].set_xlabel(labels[keys])
    axes[keys].set_ylabel("GPA")

# Mengatur susunan agar tidak berhimpitan
plt.tight_layout()

# Menampilkan plot
plt.show()

"""Dari gambar plot diatas, dapat dilihat bahwa korelasi negatif yang kuat pada ketidakhadiran (garis regresi menurun ke kanan bawah) dan korelatif positif cukup lemah pada waktu belajar setiap minggu (garis regresi naik ke kanan atas)

#  D. Data Preparation

Pada tahap ini kita akan melakukan proses transformasi pada data sehingga menjadi bentuk yang cocok untuk proses pemodelan. Ada beberapa tahap persiapan data perlu dilakukan, yaitu
1. Drop kolom yang tidak digunakan dalam pemrosesan data
2. Encoding fitur kategori
4. Pembagian dataset dengan fungsi train_test_split dari library sklearn.

### 1. Drop kolom yang tidak digunakan dalam pemrosesan data

Pada tahap ini ada beberapa kolom pada dataset yang tidak perlu digunakan dalam pemrosesan data yakni `StudentID`, `Ethnicity` dan `ParentalEducation`. Kolom-kolom ini akan dihapus menggunakan fungsi drop()
"""

df_students = df_students.drop(columns = ["StudentID"])
df_students = df_students.drop(columns = ["Ethnicity"])
df_students = df_students.drop(columns = ["ParentalEducation"])

"""Selnjutnya, kita akan mengecek informasi data siswa terbaru menggunakan fungsi info()"""

df_students.info()

"""Hasil diatas menampilkan variabel kolom `StudentID`, `Ethnicity` dan `ParentalEducation` sudah terhapus. Dataset siswa yang akan kita proses saat ini terdiri dari 2 tipe data float64, 2 tipe data int64 dan 8 tipe data objek(string).

### 2. Encoding Fitur Kategori

Pada bagian ini, karena dataset fitur kategori kita sebelumnya sudah diubah dalam bentuk objek (string) pada tahap eksplorasi data analis maka kita perlu mengubah data kategori (yang berbentuk teks atau label) menjadi format numerik agar dapat diproses oleh algoritma machine learning.
Encoding Fitur Kategorikal dilakukan 3 bagian, yakni:
1. *Label Encoding* berfungsi untuk mengonversi nilai kategori menjadi angka integer (0 dan 1)). Variabel yang akan diproses yakni:<br>
  a. `Tutoring` (Apakah siswa mengikuti bimbingan belajar?) <br>
  b. `Extracurricular` (Apakah siswa mengikuti kegiatan ektrakulikuler?) <br>
  c. `Sports` (Apakah siswa mengikuti kegiatan olahraga? <br>
  d. `Music` (Apakah siswa mengikuti kegiatan musik?) <br>
  e. `Volunteering` (Apakah siswa mengikuti kegiatan sukarelaan?)
2. *One Hot Ecoding* berfungsi untuk mengubah setiap kategori menjadi kolom biner terpisah untuk data tidak terurut). Variabel yang akan diproses yakni `Gender`.
3. *Ordinal Encoding* berfungsi untuk memberikan nilai integer berdasarkan hierarki atau urutan kategori. Variabel yang akan diproses yakni `ParentalSupport`.

Langkah pertama kita lakukan firtur kategori *Label Encoding*
"""

# Membuat list kolom-kolom kategorikal yang memiliki entri antara yes dan no
ek = ["Tutoring", "Extracurricular", "Sports", "Music", "Volunteering"]

# Mengubah nilai yes menjadi 1 dan nilai no menjadi 0 pada seluruh kolom tersebut
for k in ek:
    df_students[k] = df_students[k].map({"Yes": 1, "No": 0})

"""Langkah pertama kita lakukan firtur kategori *One hot Encoding*, karena kategori ini tidak memiliki urutan tertentu"""

# Membentuk kolom dummy dari kolom Gender
data_encoded = pd.get_dummies(df_students[["Gender"]], drop_first = True)

# Menggabungkan data asli dengan data dummy yang telah dibuat
df_students = pd.concat([df_students, data_encoded], axis = 1)

# Menghapus kolom Gender
df_students.drop(columns = ["Gender"], inplace = True)

"""Langkah pertama kita lakukan firtur kategori *Ordinal Enncoding* pada varibel`ParentalSupport` (Dukungan Orang Tua) karena kategori ini memiliki urutan yaitu ['None', 'Low', 'Moderate', 'High', 'Very High']"""

# Mendefinisikan urutan encoding
encoding_mapping = {'Very High':4, 'High':3, 'Moderate':2, 'Low':1, 'None':0}

# Lakukan encoding
df_students['ParentalSupport'] = df_students['ParentalSupport'].map(encoding_mapping)

# Menampilkan 5 baris pertama dari data setelah dilakukan data preprocessing
df_students.head()

"""### Train-Test-Split

Langkah awal, karena target kita adalah variabel GradeClass untuk mengetahui akurasi prediksi dari kategori kelas prestasi terbaik, maka kita akan membuang kolom tersebut dari data dan assign kolom tersebut ke variabel baru.
"""

# Menyiapkan fitur (X) dan target (y)
x = df_students.drop('GradeClass',axis=1)
y = df_students['GradeClass']  # Target (variabel yang diprediksi)

"""Selanjutnya kita membagi data menjadi 2, yaitu
Data training sebesar 80% untuk melatih model
Data testing sebesar 20% untuk menguji model
"""

x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.2,stratify=y,shuffle=True,random_state=15)

"""Langkah selanjutnya kita akan menampilkan ukuran data training dan testing kita yang telah kita bagi."""

# Menampilkan ukuran data training dan testing dari X dan y
print("Ukuran x_train: ", x_train.shape)
print("Ukuran x_test: ", x_test.shape)
print("Ukuran y_train: ", y_train.shape)
print("Ukuran y_test: ", y_test.shape)

"""setelah itu, kita melihat data training dat data testing kita"""

# Menampilkan 5 baris pertama dari data training X
x.head()

"""Berdasarkan data fitux (x) yang ditampilkan, terlihat data target kita GradeClass sudah terhapus dan disimpan pada variabel target (y).

Kemudian, kita melihat jumlah masing-masing *GradeClass* (Kategori Kelas) pada data testing untuk selanjutnya ditransformasikan menggunakan `LabelEncoder()`. `LabelEncoder()` berfungsi untuk memetakan setiap kategori unik dalam kolom  *GradeClass* menjadi angka integer mulai dari `0`
"""

# Menampilkan nilai-nilai dan jumlah dari variabel target
original_labels = y_test.value_counts()
original_labels

# Membentuk encoding ordinal dengan LabelEncoder
le = LabelEncoder()

# Melakukan fitting terhadap data training dan mentransformasikan data training dan testing
y_train = le.fit_transform(y_train)
y_test = le.transform(y_test)

"""# E. Model Development

Pada bagian ini, kita akan membangun 4 model machine learning untuk menguji sebarapa baik akurasi model, sehingga model tersebut yang disarankan untuk memprediksi prestasi siswa.

## 1. Model Development dengan Random Forest

1. Langkah pertama kita melatih model dengan algoritma random forest dengan memanggil fungsi RandomForestClassifier. Parameter yang digunakan yaitu:
  * `criterion="entropy"`, model akan memilih split (pembagian) yang memaksimalkan Information Gain, yaitu pengurangan entropi setelah split
  * `max_depth`, untuk mengontrol kedalaman maksimum setiap pohon keputusan dengan nilai 6
  * `n_estimators`, untuk menentukan jumlah iterasi _boosting_ (pohon keputusan)
  * `random_state`, untuk mengontrol hasil acak selama pelatihan model
"""

# Memanggil fungsi RandomForestClassifier dari library sklearn
model_rf = RandomForestClassifier(n_estimators = 200, criterion = "entropy", max_depth = 10, random_state = 50)

# Melatih model Random Forest dengan data training pada X dan y
model_rf.fit(x_train, y_train)

"""2. Langka berikutnya kita akan memprediksi dan melihat akurasi model yang telah dilatih"""

# Memprediksi hasil menggunakan data testing berdasarkan model yang telat dilatih
y_pred_rf = model_rf.predict(x_test)

# Evaluasi Model
print("Akurasi pada data uji:", accuracy_score(y_test, y_pred_rf))

"""Dari hasil yang diperoleh menunjukan model yang dibangun menggunakan algoritma Random Forest (RF) memperoleh akurasi 0.9269 (92.69%)

## 2. Model Development dengan Extreme Gradient Boosting (XGBoost)

1. Langkah pertama kita melatih model dengan Extreme Gradient Boosting (XGBoost) dengan memanggil fungsi XGBClassifier. Parameter yang digunakan yakni:
  * `max_depth`, untuk mengontrol kedalaman maksimum setiap pohon keputusan dengan nilai 6
  * `n_estimators`, untuk menentukan jumlah iterasi _boosting_ (pohon keputusan)
  * `random_state`, untuk mengontrol hasil acak selama pelatihan model
  * `learning_rate`, untuk menentukan seberapa besar kontribusi setiap pohon terhadap model akhir
  * `n_jobs`, untuk menggunakan semua CPU yang tersedia.
"""

# Memanggil fungsi XGBClassifier dari library sklearn
model_xgb = XGBClassifier(max_depth = 6, n_estimators = 125,
                          random_state = 30, learning_rate = 0.01, n_jobs = -1)

# Melatih model XGBoost dengan data training pada X dan y
model_xgb.fit(x_train, y_train)

"""2. Langka berikutnya kita akan memprediksi dan melihat akurasi model yang telah dilatih"""

# Memprediksi hasil menggunakan data testing berdasarkan model yang telat dilatih
y_pred_xgb = model_xgb.predict(x_test)

# Evaluasi Model
print("Akurasi pada data uji:", accuracy_score(y_test, y_pred_xgb))

"""Dari hasil yang diperoleh menunjukan model yang dibangun menggunakan algoritma Extreme Gradient Boosting (XGBoost) memperoleh akurasi 0.9311 (93.11%)

## 3. Model Development dengan Support Vector Machine (SVM)

1. Langkah pertama kita melatih model dengan Support Vector Machine (SVM) dengan memanggil fungsi SVC. Parameter yang dipakai yaitu:
  * `kernel='rbf'` dengan nilai parameternya `rbf`, dimana `rbf` (_Kernel Radial Basis Function_) ini cocok untuk data yang kompleks.
  * `gamma` dengan nilai default `auto` karena cocok untuk dataset yang kecil dan seragam.
  * `random_state=50`,artinya selama pelatihan data akan diacak sama sebanyak 50 kali.
"""

# Memanggil fungsi SVC dari library sklearn
model_svm = SVC(kernel = 'rbf', gamma = 'auto', random_state = 50)

# Melatih model SVM dengan data training pada X dan y
model_svm.fit(x_train, y_train)

"""2. Langka berikutnya kita akan memprediksi dan melihat akurasi model yang telah dilatih"""

# Memprediksi hasil menggunakan data testing berdasarkan model yang telat dilatih
y_pred_svm = model_svm.predict(x_test)

# Evaluasi Model
print("Akurasi pada data uji:", accuracy_score(y_test, y_pred_svm))

"""Dari hasil yang diperoleh menunjukan model yang dibangun menggunakan algoritma  Support Vector Machine (SVM) memperoleh akurasi 0.7807 (78.07%)

## 4. Model Development dengan Naive Bayes

1. Langkah pertama kita melatih model dengan Naive Bayes dengan memanggil fungsi GaussianNB() dengan parameter `var_smoothing=1e-9`. `var_smoothing` berfungsi menambahkan nilai kecil (var_smoothing) ke varians dari setiap fitur. Sedangkan Nilai `1e-9` adalah representasi ilmiah untuk angka 0.000000001 (atau `10⁻⁹`). Ini digunakan untuk menambahkan nilai kecil pada varians, sehingga tidak ada nilai varians yang terlalu kecil untuk menghasilkan masalah numerik.
"""

# Membuat model dengan parameter khusus
model_nb = GaussianNB(var_smoothing=1e-9)

# Melatih model
model_nb.fit(x_train, y_train)

"""2. Langka berikutnya kita akan memprediksi dan melihat akurasi model yang telah dilatih"""

# Memprediksi hasil menggunakan data testing berdasarkan model yang telat dilatih
y_pred_nb = model_nb.predict(x_test)

# Evaluasi Model
print("Akurasi pada data uji:", accuracy_score(y_test, y_pred_nb))

"""Dari hasil yang diperoleh menunjukan model yang dibangun menggunakan algoritma Naive Bayes memperoleh akurasi 0.7933 (79.33%)

# F. Evaluasi Model

## 1. Penerapan Matriks Confusion, Akurasi, dan Skor f1 untuk membandingkan Hasil Prediksi dengan Data Asli

Pertama kita inisialsi array models berisi hasil prediksi setiap model
"""

# Daftar model dan hasil prediksi
models = {
    'Random Forest': y_pred_rf,
    'XGBoost' : y_pred_xgb,
    "SVM": y_pred_svm,
    "Naive Bayes": y_pred_nb
}

"""Kedua, kita melihat rangkuman (*report*) dari metrik evaluasi kinerja model klasifikasi yang mencakup metrik-metrik seperti precision, recall, F1-score, dan support untuk setiap kelas dalam dataset"""

# Membuat list nama target yang diinginkan
nama_target = ['Grade A',
               'Grade B',
               'Grade C',
               'Grade D',
               'Grade F']

for i, (model_name, y_pred) in enumerate(models.items()):
  print("\nClassification Report "+model_name+":\n", classification_report(y_test, y_pred, target_names = nama_target))

"""Selanjutnya, kita bandingkan hasil prediksi dengan data asli dengan menampilkan pada headmap grafik (Matriks Confusion)"""

# Visualisasi Confusion Matrices
plt.figure(figsize=(18,6))

for i, (model_name, y_pred) in enumerate(models.items()):
    # Hitung Confusion Matrix
    cm = confusion_matrix(y_test, y_pred)
    # Plot Confusion Matrix
    plt.subplot(1, len(models), i + 1)
    sns.heatmap(
        cm,  # Data matriks korelasi
        annot=True,             # Menampilkan nilai dalam kotak
        fmt=".1f",              # Format angka
        cmap="coolwarm",        # Skema warna
        linewidths=0.2,         # Garis pembatas antar kotak
        xticklabels=nama_target,# Set nama label x
        yticklabels=nama_target,# Set nama label y
        cbar = True
    )
    plt.title(f"Confusion Matrix - {model_name}", fontsize=14)
    plt.xlabel("Predicted", fontsize=12)
    plt.ylabel("Actual", fontsize=12)


# Tampilkan semua plot
plt.tight_layout()
plt.show()

"""Berdasarkan hasil ringkasan laporan (report) dan visualisasi heatmap pada confusion matrix, diperoleh beberapa temuan sebagai berikut:

1.    Model Random Forest mencapai akurasi sebesar 0.9269 atau 92.69%. Berdasarkan confusion matrix, model ini hanya melakukan sedikit kesalahan klasifikasi, yaitu salah memprediksi 8 data pada Grade A dan 14 data pada Grade F.

2.    Model XGBoost memiliki akurasi tertinggi dengan nilai 0.9332 atau 93.32%. Kesalahan klasifikasinya pun cukup minim, yakni 5 data salah pada Grade A dan 15 data salah pada Grade F.

3.    Model Support Vector Machine (SVM) menunjukkan akurasi sebesar 0.7808 atau 78.08%. Namun, dari confusion matrix terlihat bahwa model ini cukup sering salah mengklasifikasi, dengan 16 data salah pada Grade A dan 28 data salah pada Grade F.

4.    Model Naive Bayes mencatatkan akurasi 0.7933 atau 79.33%. Meskipun sedikit lebih tinggi dari SVM, model ini juga menunjukkan tingkat kesalahan yang cukup banyak, yaitu 19 data salah pada Grade A dan 13 data salah pada Grade F.

## 2. Melihat perbandingan akurasi model dengan grafik barplot
"""

models = {
    'Random Forest': model_rf,
    'XGBoost': model_xgb,
    'Support Vector Machine': model_svm,
    'Naive Bayes': model_nb
}

model_names = []
accuracies = []

# Train and evaluate each model
for name, clf in models.items():
    clf.fit(x_train, y_train)
    score = clf.score(x_test, y_test)
    model_names.append(name)
    accuracies.append(score)
    print(f"{name} accuracy: {score:.4f}")

# Create a DataFrame for model accuracies
df_models = pd.DataFrame({'Model': model_names, 'Accuracy': accuracies})

# Plot model accuracies using Seaborn
plt.figure(figsize=(10, 6))
ax = sns.barplot( x='Model', y='Accuracy', data=df_models, legend=False)

# Mengubah warna batang secara manual
colors = ['lightcoral', 'skyblue', 'lightgreen', 'orange']  # List warna berbeda untuk setiap batang

for i, p in enumerate(ax.patches):
    p.set_color(colors[i])  # Mengubah warna setiap batang

# Menambahkan nilai di atas setiap batang
for p in ax.patches:
    ax.annotate(f'{p.get_height():.4f}',  # Menampilkan nilai
                (p.get_x() + p.get_width() / 2., p.get_height()),  # Posisi (tengah atas batang)
                ha='center', va='bottom',  # Horizontal center dan vertical top
                fontsize=12, color='black',  # Ukuran font dan warna
                xytext=(0, 5),  # Offset label untuk di atas batang
                textcoords='offset points')

plt.title('Model Accuracies')
plt.xlabel('Model')
plt.ylabel('Accuracy')
plt.ylim(0, 1)
plt.xticks(rotation=45)
plt.show()

"""Dari grafik barplot yang ditampilkan, terlihat bahwa model menggunakan algoritma Extreme Gradient Boosting (XGBoost) lebih tinggi akurasinya yakni 0.9311 dibandingkan dengan ketiga model yakni Naive Bayes = 0.7933, Random Forest = 0.9269 dan Support Vecor Machine = 0.7808 untuk memprediksi peforma siswa berdasarkan prestasi kelas terbaik."""